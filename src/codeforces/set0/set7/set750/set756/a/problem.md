Pavel 在烤串。有 \(n\) 串烤肉，它们按顺序排成一行放在烤架上，每串占据 \(n\) 个位置中的一个。Pavel 希望每一串烤肉在每一个位置上都能被烤一段时间，并且要在两个朝向都被烤到：原来的朝向以及反转后的朝向。

Pavel 有一个计划：一个排列 \(p\) 和一个由 0 和 1 组成的序列 \(b_1, b_2, \dots, b_n\)。每一秒，Pavel 会把位置 \(i\) 上的烤串移动到位置 \(p_i\)，如果 \(b_i = 1\)，那么他会把这串烤肉反转方向。所以他希望每一串烤肉都能在每个位置、两个方向上都访问到。

不幸的是，并不是每一对排列 \(p\) 和序列 \(b\) 都适合 Pavel。你需要求出：在给定的排列 \(p\) 和序列 \(b\) 中，最少需要修改多少个元素，使得每一串烤肉都能访问到全部 \(2n\) 个“放置方式”（位置 × 方向）。注意，修改之后 \(p\) 仍然必须是一个排列。

如果在 Pavel 结束烤制之前，有些烤串多次访问某些放置方式，这对他来说不成问题。换句话说，若存在一个整数 \(k\)（\(k \ge 2n\)），使得在经过 \(k\) 秒之后，每一串烤肉都访问过全部 \(2n\) 个放置方式，那么这对排列 \(p\) 和序列 \(b\) 就是适合 Pavel 的。

可以证明，对于任意的 \(n\)，总能构造出某个适合的排列 \(p\) 和序列 \(b\)。

### 输入

第一行包含一个整数 \(n\)（\(1 \le n \le 2 \cdot 10^5\)）—— 烤串的数量。

第二行包含一串整数 \(p_1, p_2, \dots, p_n\)（\(1 \le p_i \le n\)）—— Pavel 想按此排列移动烤串。

第三行包含一串由 0 和 1 组成的序列 \(b_1, b_2, \dots, b_n\)，根据该序列 Pavel 决定是否反转对应位置上的烤串。

### 输出

输出一个整数 —— 在给定的排列 \(p\) 和序列 \(b\) 中，最少需要修改的元素总数，使得每一串烤肉都能访问到全部 \(2n\) 个放置方式。

### 示例

**输入**

```text
4
4 3 2 1
0 1 1 1
```

**输出**

```text
2
```

**输入**

```text
3
2 3 1
0 0 0
```

**输出**

```text
1
```

### 说明

在第一个样例中，Pavel 可以将排列改为 \(4, 3, 1, 2\)。

在第二个样例中，Pavel 可以将 \(b\) 中任意一个元素改为 1。